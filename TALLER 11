section .data
msg db "Resultado: ", 0
len equ $ - msg
err db "Error: division entre 0", 10, 0
lenErr equ $ - err
newline db 10, 0
lenNL equ $ - newline
section .bss
resultado resb 1
section .text
global _start
_start:
; ============================
; Números hardcoded
; ============================
mov al, '8' ; primer número (ASCII)
sub al, '0' ; convertir a entero (8)
mov bl, '0' ; segundo número (ASCII) → aquí prueba el error

sub bl, '0' ; convertir a entero
; ============================
; Verificar división entre 0
; ============================
cmp bl, 0
je division_cero ; si bl == 0 saltamos
; ============================
; División AL / BL
; ============================
xor ah, ah ; limpiar AH
div bl ; resultado en AL
; Convertir resultado a ASCII
add al, '0'
mov [resultado], al
; ============================
; Imprimir "Resultado: "
; ============================
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, len
int 0x80
; Imprimir el resultado
mov eax, 4
mov ebx, 1
mov ecx, resultado
mov edx, 1
int 0x80
jmp fin ; saltar para evitar imprimir error
division_cero:
; ============================
; Imprimir mensaje de error
; ============================
mov eax, 4
mov ebx, 1
mov ecx, err

mov edx, lenErr
int 0x80
fin:
; Imprimir salto de línea
mov eax, 4
mov ebx, 1
mov ecx, newline
mov edx, lenNL
int 0x80
; Salir
mov eax, 1
xor ebx, ebx
int 0x80
// Cambios: el mensaje de error y ahora se compara el valor primero antes de dividir.
